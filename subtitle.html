<!DOCTYPE html>
<html lang="zh-CN">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>Live Subtitle</title>
        <script src="./assets/js/subtitles-octopus/subtitles-octopus.js"></script>
        <script src="https://cdn.socket.io/4.7.3/socket.io.min.js"></script>
        <style>
            .debug {
                position: absolute;
                left: 10px;
                font-size: xx-large;
                color: blue;
                display: none;
            }
            body {
                margin: 0;
                padding: 0;
                position: relative;
            }

            canvas {
                position: absolute;
            }
        </style>
    </head>
    <body>
        <canvas id="track1" width="1920" height="1080"></canvas>
        <canvas id="track2" width="1920" height="1080"></canvas>
        <div id="debugText" class="debug" style="top: 10px"></div>
        <div id="debugText2" class="debug" style="top: 50px"></div>
        <script>
            let time = [0, 0]; // 当前时间
            let hide = [true, true]; // 是否隐藏中
            let animationTime = []; // config里的动画时间
            let eachTime = []; // 每句字幕的时间
            let index = []; // 当前字幕index

            let configs = {}; // 配置信息
            let fonts = []; // 字体信息
            let subtitleIndex = 0; // 当前是第几个字幕

            async function toTime(targetTime, track = 0) {
                return new Promise((resolve, reject) => {
                    let basicTime = new Date().getTime();
                    function tick() {
                        const elapsed = Math.floor(
                            Math.min(
                                Math.abs(new Date().getTime() - basicTime),
                                Math.abs(targetTime - time[track])
                            )
                        );
                        basicTime = new Date().getTime();
                        time[track] +=
                            targetTime - time[track] > 0 ? elapsed : -elapsed;
                        window.octopusInstance[track].setCurrentTime(
                            time[track] / 1000
                        );
                        document.getElementById(
                            "debugText"
                        ).innerHTML = `track1: ${time[0] / 1000}`;
                        document.getElementById(
                            "debugText2"
                        ).innerHTML = `track2: ${time[1] / 1000}`;
                        const difference = Math.abs(targetTime - time[track]);
                        if (difference > 0) {
                            requestAnimationFrame(tick);
                        } else {
                            resolve();
                        }
                    }
                    const difference = Math.abs(targetTime - time[track]);
                    if (difference > 0) {
                        requestAnimationFrame(tick);
                    }
                });
            }

            fetch("/assets/subtitles/config.json")
                .then((data) => data.json())
                .then((data) => {
                    configs = data.configs;
                    fonts = data.fonts;
                })
                .then(() => {
                    init();
                    window.octopusInstance = [];
                    const optionsTrack1 = {
                        canvas: document.getElementById("track1"),
                        subUrl:
                            "/assets/subtitles/" + configs[subtitleIndex].file,
                        fonts: fonts.map((i) => "/assets/fonts/" + i),
                        workerUrl:
                            "./assets/js/subtitles-octopus/subtitles-octopus-worker.js",
                        debug: true,
                    };
                    const optionsTrack2 = {
                        canvas: document.getElementById("track2"),
                        subUrl:
                            "/assets/subtitles/" + configs[subtitleIndex].file2,
                        fonts: fonts.map((i) => "/assets/fonts/" + i),
                        workerUrl:
                            "./assets/js/subtitles-octopus/subtitles-octopus-worker.js",
                        debug: true,
                    };
                    window.octopusInstance[0] = new SubtitlesOctopus(
                        optionsTrack1
                    );
                    window.octopusInstance[0].setCurrentTime(time[0] / 1000);
                    window.octopusInstance[1] = new SubtitlesOctopus(
                        optionsTrack2
                    );
                    window.octopusInstance[1].setCurrentTime(time[1] / 1000);
                });

            function init() {
                animationTime[0] = configs[subtitleIndex].animationTime;
                animationTime[1] = configs[subtitleIndex].animationTime2;
                eachTime[0] = animationTime[0].in + animationTime[0].out;
                eachTime[1] =
                    (animationTime[1]?.in ?? 0) + (animationTime[1]?.out ?? 0);
                index = [-1, -1];
                hide = [true, true];
                time = [0, 0];
            }

            async function next(track = 0) {
                await goin(index[track] + 1, track);
                hide[track] = false;
                return index[track];
            }

            async function goin(_index, track = 0) {
                if (_index > 0 && !hide[track]) {
                    await _hide(track);
                }
                index[track] = _index;
                console.log(index);
                time[track] = _index * eachTime[track];
                toTime(
                    _index * eachTime[track] + animationTime[track].in,
                    track
                );
            }

            async function _hide(track) {
                if (hide[track]) {
                    goin(index[track], track);
                    hide[track] = false;
                    return;
                }
                time[track] =
                    index[track] * eachTime[track] + animationTime[track].in;
                await toTime((index[track] + 1) * eachTime[track], track);
                hide[track] = true;
            }

            const socket = io();
            socket.on("set", async (settings) => {
                if (
                    typeof settings.subtitleIndex == "number" &&
                    settings.subtitleIndex !== subtitleIndex
                ) {
                    subtitleIndex = settings.subtitleIndex;
                    init();
                    window.octopusInstance[0].setTrackByUrl(
                        "/assets/subtitles/" + configs[subtitleIndex].file
                    );
                    window.octopusInstance[0].setCurrentTime(0);
                    window.octopusInstance[1].setTrackByUrl(
                        "/assets/subtitles/" + configs[subtitleIndex].file2
                    );
                    window.octopusInstance[1].setCurrentTime(0);
                    return;
                }
                if (settings.step == "next") {
                    next(settings.track);
                } else if (settings.step == "hide") {
                    _hide(settings.track);
                } else if (settings.step == "to") {
                    await goin(settings.index, settings.track);
                    hide[settings.track] = false;
                }
            });
        </script>
    </body>
</html>
